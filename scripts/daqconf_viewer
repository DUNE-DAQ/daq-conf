#!/usr/bin/env python3
import asyncio
import copy
import click
import httpx
import json
import sys

from difflib import unified_diff
from pathlib import Path
from rich.markdown import Markdown
from rich.text import Text

from textual import log, events
from textual.app import App, ComposeResult
from textual.containers import Content, Container, Horizontal, Vertical
from textual.reactive import reactive, Reactive
from textual.screen import Screen
from textual.widget import Widget
from textual.widgets import Button, DirectoryTree, Footer, Header, Input, Label, ListItem, ListView, Static, Tree

auth = ("fooUsr", "barPass")
oldconf = None
oldconfname = None
oldconfver = None

class TitleBox(Static):
    def __init__(self, title, **kwargs):
        super().__init__(Markdown(f'# {title}'))

    def update(self, text):
        super().update(Markdown(f'# {text}'))

class LabelItem(ListItem):
    def __init__(self, label: str) -> None:
        super().__init__()
        self.label = label

    def compose( self ) -> ComposeResult:
        yield Label(self.label)

class Configs(Static):
    conflist = reactive([])

    def __init__(self, hostname, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname
        self.term = ""

    def on_mount(self) -> None:
        self.set_interval(0.1, self.update_configs)

    def compose(self) -> ComposeResult:
       yield TitleBox('Configurations')
       yield Input(placeholder='Search Configs')
       yield ListView(LabelItem("This shouldn't be visible!"))

    async def update_configs(self) -> None:
        try:
            async with httpx.AsyncClient() as client:
                r = await client.get(f'{self.hostname}/listConfigs', auth=auth, timeout=5)
            unsorted = r.json()['configs']
            self.conflist = sorted(unsorted, key=str.lower)
        except Exception as e:
            #Exiting the program mid-request causes a CancelledError: we don't want to call our function
            #in this case, as it will not be able to find the relevent widgets.
            if isinstance(e, asyncio.CancelledError):
               return
            self.display_error(f"Couldn't retrieve configs from {self.hostname}/listConfigs\nError: {e}")

    def watch_conflist(self, conflist:list[str]):
        self.display_conflist()

    async def on_input_changed(self, message: Input.Changed) -> None:
        '''This event occurs whenever the user types in the search box.'''
        self.term = message.value
        self.display_conflist()

    def display_conflist(self) -> None:
        '''
        We regenerate the list whenever the actual list of configs changes, or whenever the user types in the search box.
        #If the box is empty, don't filter, else we require that the search term is in the name
        '''
        if self.term == "":
            filtered = self.conflist
        else:
            filtered = [name for name in self.conflist if self.term in name]

        label_list = [LabelItem(f) for f in filtered]
        the_list = self.query_one(ListView)
        the_list.clear()
        for item in label_list:
            the_list.append(item)

    def on_list_view_selected(self, event: ListView.Selected):
        confname = event.item.label
        for v in self.screen.query(Vertical):
            if isinstance(v, Versions):
                v.new_conf(confname)
                break

    def display_error(self, text):
        '''If something goes wrong with getting the configs, we hijack the display to tell the user.'''
        for v in self.screen.query(Vertical):
            if isinstance(v, Display):
                e_json = {'error': text}
                v.confdata = e_json
                break
            if isinstance(v, DiffDisplay):
                for s in v.query(Static):
                    if s.id == 'diffbox':
                       s.update(text)
                       break

class ShortNodeTree(DirectoryTree):
    '''We inherit everything from the dirtree, but we want to abbreviate the top node.'''
    def process_label(self, label):
        '''If a node is a/b/c, just display c'''
        if '/' in label:
            good_label = label.split('/')[-1]
        else:
            good_label = label
        if isinstance(good_label, str):
            text_label = Text.from_markup(good_label)
        else:
            text_label = good_label
        first_line = text_label.split()[0]
        return first_line

class LocalConfigs(Static):
    conflist = reactive([])

    def __init__(self, hostname, path, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname
        path_obj = Path(path)
        self.path = str(path_obj.resolve())

    def compose(self) -> ComposeResult:
       yield TitleBox('Configurations')
       yield Input(placeholder='Search Configs')
       yield ShortNodeTree(self.path)

    async def on_directory_tree_file_selected(self, event: DirectoryTree.FileSelected ) -> None:
        location = event.path
        filename = location.split('/')[-1]
        try:
            with open(location) as f:
                self.current_conf = json.load(f)
            #Look for a display to show the config to
            for v in self.screen.query(Vertical):
                if isinstance(v, Display) or isinstance(v, DiffDisplay):
                    await v.get_json_local(filename, self.current_conf)
                    break
        except Exception as e:
           self.display_error(f"Config at {location} is not usable\n Error: {e}")

    def display_error(self, text):
        '''If something goes wrong with getting the configs, we hijack the display to tell the user.'''
        for v in self.screen.query(Vertical):
            if isinstance(v, Display):
                e_json = {'error': text}
                v.confdata = e_json
                break
            if isinstance(v, DiffDisplay):
                for s in v.query(Static):
                    if s.id == 'diffbox':
                       s.update(text)
                       break

class Versions(Vertical):
    vlist = reactive([])

    def __init__(self, hostname, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname
        self.current_conf = None
        self.reverse = True

    def compose(self) -> ComposeResult:
       yield TitleBox(f'Configuration versions')
       yield Horizontal(id='buttonbox')

    def on_mount(self) -> None:
        self.set_interval(0.1, self.update_versions)

    def new_conf(self, conf) -> None:
        self.current_conf = conf

    async def update_versions(self) -> None:
        if self.current_conf:
            try:
                async with httpx.AsyncClient() as client:
                    payload = {'name': self.current_conf}
                    r = await client.get(f'{self.hostname}/listVersions', auth=auth, params=payload, timeout=5)
                numlist = r.json()['versions']          #This is a list of ints
                if self.reverse:
                    numlist.reverse()
                self.vlist = numlist
            except Exception as e:
                if isinstance(e, asyncio.CancelledError):
                    self.display_error(f"Couldn't retrieve versions from {self.hostname}/listVersions\nError: {e}")

    def watch_vlist(self, vlist:list[int]) -> None:
        bb = self.query_one(Horizontal)
        old_buttons = bb.query(Button)
        for b in old_buttons:
           b.remove()
        for v in vlist:
            b_id = 'v' + str(v)                        #An id can't be just a number for some reason
            bb.mount(Button(str(v), id=b_id, classes='vbuttons', variant='primary'))

    async def on_button_pressed (self, event: Button.Pressed) -> None:
        button_id = event.button.id
        version = int(button_id[1:])
        for v in self.screen.query(Vertical):
            if isinstance(v, Display) or isinstance(v, DiffDisplay):
                await v.get_json(self.current_conf, version)
                break

    def display_error(self, text):
        '''If something goes wrong with getting the configs, we hijack the display to tell the user.'''
        for v in self.screen.query(Vertical):
            if isinstance(v, Display):
                e_json = {'error': text}
                v.confdata = e_json
                break
            if isinstance(v, DiffDisplay):
                for s in v.query(Static):
                    if s.id == 'diffbox':
                       s.update(text)
                       break

class Display(Vertical):
    confdata = reactive(None)

    def __init__(self, hostname, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname
        self.confname = None
        self.version = None

    def compose(self) -> ComposeResult:
       yield TitleBox('Configuration data')
       yield Tree("", id='conftree')

    async def get_json(self, conf, ver) -> None:
        self.confname = conf
        self.version = ver
        if self.confname != None and self.version != None:
            try:
                async with httpx.AsyncClient() as client:
                    payload = {'name': self.confname, 'version': self.version}
                    r = await client.get(f'{self.hostname}/retrieveVersion', auth=auth, params=payload, timeout=5)
                self.confdata = r.json()
            except:
                self.confdata = {"error": f"Couldn't retrieve the configuration at {self.hostname}/retrieveVersion (payload: {payload}"}

    async def get_json_local(self, name, conf) -> None:
        self.confname = name
        self.version = -1
        self.confdata = conf

    def json_into_tree(cls, node, json_data):
        """Takes a JSON, and puts it into the tree."""
        from rich.highlighter import ReprHighlighter

        highlighter = ReprHighlighter()

        def add_node(name, node, data) -> None:
            """Adds a node to the tree.
            Args:
                name (str): Name of the node.
                node (TreeNode): Parent node.
                data (object): Data associated with the node.
            """
            if isinstance(data, dict):
                node.set_label(Text(f"{{}} {name}"))
                for key, value in data.items():
                    new_node = node.add("")
                    add_node(key, new_node, value)
            elif isinstance(data, list):
                node.set_label(Text(f"[] {name}"))
                for index, value in enumerate(data):
                    new_node = node.add("")
                    add_node(str(index), new_node, value)
            else:
                node.allow_expand = False
                if name:
                    label = Text.assemble(
                        Text.from_markup(f"[b]{name}[/b]="), highlighter(repr(data))
                    )
                else:
                    label = Text(repr(data))
                node.set_label(label)

        add_node("", node, json_data)

    def watch_confdata(self, confdata:dict) -> None:
        if confdata:
            tree = self.query_one(Tree)
            tree.clear()
            self.json_into_tree(tree.root, confdata)
            tree.root.expand()

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if self.confdata:
            self.app.mount(DiffScreen(self.hostname, self.confdata, id='diffscreen'))

class DiffDisplay(Vertical):
    confdata = reactive(None)

    def __init__(self, hostname, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname
        self.confname = None
        self.version = None

    def compose(self) -> ComposeResult:
        yield TitleBox("Diff")
        yield Vertical(Static(id='diffbox'))

    def on_mount(self) -> None:
        self.set_interval(0.1, self.update_title)

    def update_title(self) -> None:
        #If the config is local, we set the version number to -1
        vold = "(local)" if oldconfver == -1 else f"(v{oldconfver})"
        vnew = "(local)" if self.version == -1 else f"(v{self.version})"

        if self.version != None:
            difftext = f"Comparing {str(oldconfname)} {vold} with {self.confname} {vnew}"
        else:
            difftext = f"Comparing {str(oldconfname)} {vold} with..."
        title = self.query_one(TitleBox)
        title.update(difftext)

    async def get_json(self, conf, ver) -> None:
        self.confname = conf
        self.version = ver
        if self.confname != None and self.version != None:
            try:
                async with httpx.AsyncClient() as client:
                    payload = {'name': self.confname, 'version': self.version}
                    r = await client.get(f'{self.hostname}/retrieveVersion', auth=auth, params=payload, timeout=5)
                self.confdata = r.json()
            except:
                self.confdata = {"error": f"Couldn't retrieve the configuration at {self.hostname}/retrieveVersion (payload: {payload})"}

    async def get_json_local(self, name, conf) -> None:
        self.confname = name
        self.version = -1
        self.confdata = conf

    async def watch_confdata(self, confdata:dict) -> None:
        '''Turns the jsons into a string format with newlines, then generates a diff of the two.'''
        if confdata:
            if "error" in confdata:
                for s in self.query(Static):
                  if s.id == 'diffbox':
                      s.update(confdata['error'])
                      break
            else:
                j1 = copy.deepcopy(oldconf)
                j2 = copy.deepcopy(confdata)
                if "_id" in j1: del j1["_id"]       #We don't want to include the ID in the diff since it's always different.
                if "_id" in j2: del j2["_id"]
                a = json.dumps(j1, sort_keys=True, indent=4).splitlines(keepends=True)
                b = json.dumps(j2, sort_keys=True, indent=4).splitlines(keepends=True)
                delta = unified_diff(a,b)
                diff = Text()
                for d in delta:
                    sym = d[0]
                    match sym:
                        case '+':
                            t = Text(d, style='green')
                        case '-':
                            t = Text(d, style='red')
                        case '@':
                            t = Text(d, style='gold1')
                        case _:
                            t = Text(d)
                    diff += t

                for s in self.query(Static):
                  if s.id == 'diffbox':
                      s.update(diff)
                      break

    def on_button_pressed(self) -> None:
        self.remove()

class LocalDiffScreen(Screen):
    BINDINGS = [
        ("l", "switch_local", "DB Files"),
        ("d", "end_diff", "Return")
    ]

    def __init__(self, hostname, path, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname
        self.path = path

    def compose(self) -> ComposeResult:
        yield LocalConfigs(hostname=self.hostname, path=self.path, classes='greencontainer configs', id='localdiffconfigs')
        yield DiffDisplay(hostname=self.hostname, classes='greencontainer display', id='localdiffdisplay')

        yield Header(show_clock=True)
        yield Footer()

    def action_switch_local(self) -> None:
        self.app.pop_screen()
        self.app.push_screen('diff')

    def action_end_diff(self) -> None:
        self.app.pop_screen()
        self.app.push_screen('lconf')


class DiffScreen(Screen):
    BINDINGS = [
        ("l", "switch_local", "Local Files"),
        ("d", "app.pop_screen", "Return")
    ]

    def __init__(self, hostname, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname

    def compose(self) -> ComposeResult:
        yield Configs(hostname=self.hostname, classes='greencontainer configs', id='diffconfigs')
        yield Versions(hostname=self.hostname, classes='greencontainer versions', id='diffversions')
        yield DiffDisplay(hostname=self.hostname, classes='greencontainer display', id='diffdisplay')

        yield Header(show_clock=True)
        yield Footer()

    def action_switch_local(self) -> None:
        self.app.pop_screen()
        self.app.push_screen('ldiff')


class LocalConfScreen(Screen):
    BINDINGS = [
        ("l", "app.pop_screen", "DB Files"),
        ("d", "make_diff", "Diff")
    ]
    def __init__(self, hostname, path, **kwargs):
        super().__init__(**kwargs)
        self.hostname = hostname
        self.path = path

    def compose(self) -> ComposeResult:
        yield LocalConfigs(hostname=self.hostname, path=self.path, classes='redcontainer configs', id='localconfigs')
        yield Display(hostname=self.hostname, classes='redcontainer display', id='localdisplay')

        yield Header(show_clock=True)
        yield Footer()

    def action_make_diff(self) -> None:
        '''Saves the current config to a global variable, then pushes the (local) diff screen.'''
        dis = self.query_one(Display)
        if dis.confdata != None:
           global oldconf, oldconfname, oldconfver
           oldconf, oldconfname, oldconfver = dis.confdata, dis.confname, dis.version
           self.app.pop_screen()
           self.app.push_screen('ldiff')

class ConfViewer(App):
    CSS_PATH = "daqconf_viewer.css"
    BINDINGS = [
        ("l", "switch_local", "Local Files"),
        ("d", "make_diff", "Diff"),
        ("v", "flip_versions", "Reverse Version Order"),
        ("q", "quit", "Quit"),
    ]

    def __init__(self, host, port, dir, **kwargs):
        super().__init__(**kwargs)
        self.hostname = f"{host}:{port}"
        self.path = dir

    def on_mount(self) -> None:
        self.install_screen(LocalConfScreen(hostname=self.hostname, path=self.path), name="lconf")
        self.install_screen(DiffScreen(hostname=self.hostname), name="diff")
        self.install_screen(LocalDiffScreen(hostname=self.hostname, path=self.path), name="ldiff")

    def compose(self) -> ComposeResult:
        yield Configs(hostname=self.hostname, classes='redcontainer configs', id='regconfigs')
        yield Versions(hostname=self.hostname, classes='redcontainer versions', id='regversions')
        yield Display(hostname=self.hostname, classes='redcontainer display', id='regdisplay')

        yield Header(show_clock=True)
        yield Footer()

    def action_switch_local(self) -> None:
        self.push_screen('lconf')

    def action_make_diff(self) -> None:
        '''Saves the current config to a global variable, then pushes the diff screen.'''
        dis = self.screen.query_one(Display)
        if dis.confdata != None:
           global oldconf, oldconfname, oldconfver
           oldconf, oldconfname, oldconfver = dis.confdata, dis.confname, dis.version
           self.push_screen('diff')

    def action_flip_versions(self) -> None:
        '''
        Tells the versions widget to display them the other way around.
        If that widget doesn't exist on this scren, do nothing.
        '''
        try:
            ver = self.screen.query_one(Versions)
            ver.reverse = not ver.reverse
        except:
            pass

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])
@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--host', default="http://np04-srv-023", help='Machine hosting the config service')
@click.option('--port', default="31011", help='Port that the config service listens on')
@click.option('--dir', default = "./", help='Top-level directory to look for local files in')
def start(host:str, port:str, dir:str):
    app = ConfViewer(host, port, dir)
    app.run()

if __name__ == "__main__":
    start()
